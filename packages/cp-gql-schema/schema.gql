
  scalar Date
  scalar Object

  type Portal {
    user: User!
    datacenter: Datacenter!
    deploymentGroups: [DeploymentGroup]!
  }

  type User {
    id: ID!
    firstName: String!
    lastName: String!
    email: String!
    login: String!
  }

  type DeploymentGroup {
    id: ID!
    name: String!
    slug:  String!
    services(slug: String): [Service]!
    version: Version!
    history: [Version]!
  }

  type ServiceScale {
    id: ID!
    serviceName: String!
    replicas: Int!
  }

  enum ConvergenceActionType {
     NOOP
     CREATE
     RECREATE
     START
   }

  type ConvergenceAction {
    id: String!
    type: ConvergenceActionType!
    service: String! # service name
    machines: [String]! # instance machine ids
  }

  type StateConvergencePlan {
    id: String!
    running: Boolean!
    actions: [ConvergenceAction]!
  }

  type Version {
    created: Date! # Either Int or define scalar
    manifest: Manifest!
    scale: [ServiceScale]!
    plan: StateConvergencePlan
  }

  enum ManifestType {
    COMPOSE
    MARIPOSA
  }

  enum ManifestFormat {
    JSON
    YAML
  }

  type Manifest {
    id: String!
    created: Date!
    type: ManifestType!
    format: ManifestFormat!
    raw: String!
    obj: Object!
  }

  # immutable
  type Service {
    id: String! # unique id for db row
    hash: String! # unique id for version of service
    name: String! # human readable name
    slug:  String!
    instances: [Instance]!
    # metrics: [MetricType]!
    currentMetrics: [CurrentMetric]!
    connections: [String!] # list of serviceIds
    parent: ID # parent service id
    package: Package! # we don't have this in current mock data,
    environment: [Environment]
  }

  # for metrics max / min (I guess)
  type Package {
    id: ID!
    name: String!
    type: String!
    memory: Float!
    disk: Float!
    swap: Float!
    lwps: Int!
    vcpus: Int!
    version: String!
    group: String!
  }

  # environment variables
  type Environment {
    name: String!
    value: String!
  }

  enum InstanceStatus {
    CREATED
    RESTARTING
    RUNNING
    PAUSED
    EXITED
    DELETED
  }

  type Instance {
    id: String!
    name: String!
    machineId: String!
    status: InstanceStatus!
    # metrics: [InstanceMetric]!
  }

  type Datacenter {
    id: String!
    url: String!
    name: String!
    region: String!
  }

  type InstanceMetric {
    type: MetricType!
    data: [MetricData]!
  }

  type CurrentMetric {
    name: String!
    value: Float!
    measurement: String!
  }

  type MetricType {
    id: String!
    name: String!
    id: String!
  }

  type MetricData {
    timestamp: Int!
    value: Float!
  }

  # Need to review queries
  type Query {
    portal: Portal
    deploymentGroups: [DeploymentGroup]
    deploymentGroup(id: String, slug: String): DeploymentGroup
    services(deploymentGroupId: String, deploymentGroupSlug: String): [Service]
    service(id: String, slug: String): Service
    instances(serviceId: String, serviceSlug: String): [Instance]
    instance(id: String, machineId: String): Instance
    metricTypes: [MetricType]
    metricData(instanceId: String!, metricType: String!, from: Date!, to: Date!): [InstanceMetric]!
    package: Package
    datacenters: [Datacenter]
    # tmp test
    instanceMetric: InstanceMetric!
  }

  # we probably wont use some of these queries or arguments
  # but this way we expose the entire db through gql
  type Query {
    portal: Portal
    user: User
    deploymentGroups(name: String, slug: String): [DeploymentGroup]
    deploymentGroup(id: ID, name: String, slug: String): DeploymentGroup
    serviceScales(serviceName: String, versionId: ID): [ServiceScale]
    serviceScale(id: ID!): ServiceScale
    convergenceActions(type: ConvergenceActionType, service: String, versionId: ID): [ConvergenceAction]
    convergenceAction(id: ID!): ConvergenceAction
    stateConvergencePlans(running: Boolean, versionId: ID): [StateConvergencePlan]
    stateConvergencePlan(id: ID!): StateConvergencePlan
    versions(manifestId: ID, deploymentGroupId: ID): [Version]
    version(id: ID, manifestId: ID): Version
    manifests(type: String, deploymentGroupId: ID): [Manifest]
    manifest(id: ID!): Manifest
    services(name: String, slug: String, parentId: ID, deploymentGroupId: ID, deploymentGroupSlug: String): [Service]
    service(id: ID, hash: ID): Service
    packages(name: String, type: String, memory: Int, disk: Int, swap: Int, lwps: Int, vcpus: Int, version: String, group: String): [Package]
    package(id: ID!): Package
    instances(name: String!, machineId: ID, status: InstanceStatus, serviceId: ID, serviceSlug: String, deploymentGroupId: ID, deploymentGroupSlug: String): [Instance]
    instance(id: ID!): Instance
    datacenter(id: ID, region: String): Datacenter
    datacenters: [Datacenter]
  }

  type Mutation {
    createDeploymentGroup(name: String!) : DeploymentGroup
    updateDeploymentGroup(id: ID!, name: String!) : DeploymentGroup

    provisionManifest(deploymentGroupId: ID!, type: ManifestType!, format: ManifestFormat!, raw: String!) : Manifest
    scale(service: ID!, replicas: Int!) : Version

    stopServices(ids: [ID]!) : [Service]
    startServices(ids: [ID]!) : [Service]
    restartServices(ids: [ID]!) : [Service]
    deleteServices(ids: [ID]!) : [Service]

    stopInstances(ids: [ID]!) : [Instance]
    startInstances(ids: [ID]!) : [Instance]
    restartInstances(ids: [ID]!) : [Instance]

    # reprovision() ???
  }
